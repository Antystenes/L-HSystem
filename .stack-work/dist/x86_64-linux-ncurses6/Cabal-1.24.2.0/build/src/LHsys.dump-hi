
==================== FINAL INTERFACE ====================
2017-02-19 20:41:40.509488477 UTC

interface L-HSystem-0.1.0.0-H6K4ZpJw9Dw25dilqcdZNx:LHsys 8002
  interface hash: fa74066f9876c33b53cc57345384be79
  ABI hash: 57c551d14280d425d548e228d4a25005
  export-list hash: bf86b990fdea18fa5ce1bf41f372c4e0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: bf8f5ed9f57c603c45732fbe6e5757d5
  sig of: Nothing
  used TH splices: False
  where
exports:
  LHsys.step
  LHsys.LSys{LHsys.LSys inst rewr}
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
c8df2cbfd3fabda3623a8f051cca5a1b
  $fShowLSys :: GHC.Show.Show sym => GHC.Show.Show (LHsys.LSys sym)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,A,C(C1(U)))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ sym ($dShow :: GHC.Show.Show sym).
                  @ (LHsys.LSys sym)
                  (LHsys.$fShowLSys_$cshowsPrec @ sym $dShow)
                  (LHsys.$fShowLSys_$cshow @ sym $dShow)
                  (LHsys.$fShowLSys_$cshowList @ sym $dShow) -}
c8df2cbfd3fabda3623a8f051cca5a1b
  $fShowLSys_$cshow ::
    GHC.Show.Show sym => LHsys.LSys sym -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLC(C(S))),1*U(A,A,1*C1(C1(U)))><L,1*U(1*U,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ sym ($dShow :: GHC.Show.Show sym) (eta :: LHsys.LSys sym) ->
                 GHC.Show.showList
                   @ sym
                   $dShow
                   (case eta of wild { LHsys.LSys ds ds1 -> ds })
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c8df2cbfd3fabda3623a8f051cca5a1b
  $fShowLSys_$cshowList ::
    GHC.Show.Show sym => [LHsys.LSys sym] -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)))><S,1*U><L,U>,
     Unfolding: (\ @ sym
                   ($dShow :: GHC.Show.Show sym)
                   (ls :: [LHsys.LSys sym])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (LHsys.LSys sym)
                   (\ (x :: LHsys.LSys sym) (s1 :: GHC.Base.String)[OneShot] ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Show.showList
                         @ sym
                         $dShow
                         (case x of wild { LHsys.LSys ds ds1 -> ds })
                         (GHC.Types.[] @ GHC.Types.Char))
                      s1)
                   ls
                   s) -}
c8df2cbfd3fabda3623a8f051cca5a1b
  $fShowLSys_$cshowsPrec ::
    GHC.Show.Show sym =>
    GHC.Types.Int -> LHsys.LSys sym -> GHC.Show.ShowS
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLC(C(S))),1*U(A,A,1*C1(C1(U)))><L,A><L,1*U(1*U,A)><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ sym
                   ($dShow :: GHC.Show.Show sym)
                   (ds :: GHC.Types.Int)
                   (x :: LHsys.LSys sym)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (GHC.Show.showList
                         @ sym
                         $dShow
                         (case x of wild { LHsys.LSys ds1 ds2 -> ds1 })
                         (GHC.Types.[] @ GHC.Types.Char)))
                   s) -}
b847ce5cf51d0145aae6a87b0b26e842
  $tc'LSys :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17468074367145332024##
                   10525558462547032891##
                   LHsys.$trModule
                   LHsys.$tc'LSys1) -}
56733c1cf33740eb25f5541794049d98
  $tc'LSys1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LSys"#) -}
a6d7207428e10d1934dd8ce0357380f7
  $tcLSys :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3419978878683273234##
                   13354157239385939891##
                   LHsys.$trModule
                   LHsys.$tcLSys1) -}
2a5beeda31ed3ff4703745c7d278dc0b
  $tcLSys1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "LSys"#) -}
9dd7d26ae9f86638aaf65d0be4d6df23
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module LHsys.$trModule2 LHsys.$trModule1) -}
c603faecefb37e8c4e463de3d0eecd3d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "LHsys"#) -}
a701af2a0cc122f783cef1b7e4d5a45e
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "L-HSystem-0.1.0.0-H6K4ZpJw9Dw25dilqcdZNx"#) -}
c8df2cbfd3fabda3623a8f051cca5a1b
  data LSys sym = LSys {inst :: [sym], rewr :: sym -> [sym]}
ad371206f0ed24e4e349c360b8657805
  inst :: LHsys.LSys sym -> [sym]
  RecSel Left LHsys.LSys
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ sym (ds :: LHsys.LSys sym) ->
                 case ds of wild { LHsys.LSys ds1 ds2 -> ds1 }) -}
26697a91aff6c49c741a8f173f0032d5
  rewr :: LHsys.LSys sym -> sym -> [sym]
  RecSel Left LHsys.LSys
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ sym (ds :: LHsys.LSys sym) ->
                 case ds of wild { LHsys.LSys ds1 ds2 -> ds2 }) -}
11fd61edec740a74e63bcea9693892f4
  step :: LHsys.LSys a -> LHsys.LSys a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: LHsys.LSys a) ->
                 case ds of wild { LHsys.LSys i r ->
                 LHsys.LSys @ a (GHC.Base.$fMonad[]_$c>>= @ a @ a i r) r }) -}
instance [safe] GHC.Show.Show [LHsys.LSys] = LHsys.$fShowLSys
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

